{{{ imports }}} {{{ implements encoding }}} {{{ members }}} {{{ members {{{ instance variables }}} delegate read to the iso i s o 8859 1 does not start escape sequence or is escaped eof e o f which is signalled by 1 is also captured check for following character eof e o f reached not an escape sequence read in remainder of possible escape sequence eof e o f reached during escape sequence read < 5 doesn't necessarily mean eof e o f but could also mean no more input available currently so try to read on we have really hit eof e o f so there is not enough input for an escape sequence no unicode escape with non hex characters in positions 3 6 valid unicode escape read 5 chars more than requested to have more input if last character is a '\' delegate read to the iso i s o 8859 1 eof e o f reached read = read from underlying stream result = read after conversion how many additional characters need to be read because of collapsed escape sequences iterate read chars but maximum len ones character under consideration does not start escape sequence add to result buffer and continue to next character less than 5 characters left after current position because either there was no more input available or because of eof e o f try to read in more characters to complete the escape sequence read in missing characters eof e o f reached add to result buffer and continue to next character if permissive or eof e o f reached after backslash or not an escape sequence otherwise throw no unicode escape without 'u' at second position add to result buffer and continue to next character no unicode escape with non hex characters in positions 3 6 add to result buffer and continue to next character if permissive otherwise throw valid unicode escape need 5 more chars that were consumed for escape collapsing but only if the escape sequence was not in the additional space advance pointer nothing was collapsed read more chars due to escape collapsing eof e o f reached {{{ members {{{ instance variables }}} }}} }}} 