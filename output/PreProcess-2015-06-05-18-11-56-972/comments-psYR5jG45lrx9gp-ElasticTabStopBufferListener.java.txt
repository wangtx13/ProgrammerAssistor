{{{ elastictabstopbufferlistener elastic tab stop buffer listener }}} {{{ fullyupdatecolumnblocks fully update column blocks textarea text area getpainter get painter repaint }}} {{{ contentinserted content inserted out before b e f o r e updating u p d a t i n g column c o l u m n blocks b l o c k s out rootblock root block if the line lies within this block we need to redraw it a simple char has been entered no newline if this lies inside a column block update the startindex start index and endindex end index of this blocks corresponding columnblockline column block line and all subsequent columnblock column block lines after this one check whether columnblockwidth column block width is valid do nothing if this char does not lie inside a column block no need to update line offset as columnblock column block would be rebuilt startingline starting line = innercontainingblock inner containing block startline start line endline end line = innercontainingblock inner containing block endline end line innerparent inner parent getchildren get children remove innercontainingblock inner containing block /*else if innercontainingblock==null inner containing block==null singletabinserted single tab inserted 
				{
					 todo t o d o handle this case when tab has been inserted in front f r o n t and not outside o u t sid e of a column block
					 currently whole column block gets repainted in this case
				}*/ this line must have been retokenized and repainted by the bufferhandler buffer handler so repaint it again here after column blocks dirty status is updated out after a f t e r updating u p d a t i n g column c o l u m n blocks b l o c k s out rootblock root block }}} {{{ contentremoved content removed we need to remove column blocks find the column block lying just below the first line deleted info we need to determine inside this if block deletion above block if last line lies above this block cannot be connected to a block above in this deletion without touching the block above /*if justbelowblock just below block startline+numlines+1==firstblockeffected start line+num lines+1==first block effected startline start line 
					{
						startlinetobuild=blockabovefirsteffected 
					{
						start line to build=block above first effected startline start line 
						endlinetobuild= 
						end line to build= firstblockeffected first block effected endline end line 
						firstblocktoberemoved 
						first block to be removed = blockabovefirsteffected block above first effected 
						lastblocktoberemoved 
						last block to be removed = firstblockeffected first block effected 
					}*/ else {	 }	 deletion inside block if indexfirstblockeffected<rootblock index first block effected<root block getchildren get children size 1 {	 firstblocktobeupdated first block to be updated = columnblock column block rootblock root block getchildren get children get indexfirstblockeffected+1 index first block effected+1 }	 deletion might cover other blocks as well deletion partially overlaps this block if indexlastblock<rootblock index last block<root block getchildren get children size 1 { firstblocktobeupdated first block to be updated = columnblock column block rootblock root block getchildren get children get indexlastblock+1 index last block+1 } deletion lies above this block do not need to consider blockjustabove block just above here as we cannot connect two column blocks without ending on one of the lines of either firstblocktobeupdated first block to be updated = blockbelow block below if we have reached here there is surely a block above this one if the first block is wholly covered then all column blocks are being deleted completely and there is nothing to build consider the case where last line deleted is just above the column block block below no block below last line firstblocktobeupdated first block to be updated = deletion lies below all column blocks firstblocktobeupdated first block to be updated = once we reach here we have three things to do 1 delete columnblocks column blocks using firstblocktobedeleted first block to be deleted and lastblocktobedeleted last block to be deleted 2 update startline/endline start line/end line in column blocks using firstblocktobeupdated first block to be updated start just after the last block to be removed once we are done with 2 we can safely change rootblock root block 3 rebuild column blocks using endline end line and startline start line a simple char has been entered if this lies inside a column block update the startindex start index and endindex end index of this blocks corresponding columnblockline column block line and all subsequent columnblock column block lines after this one check whether columnblockwidth column block width is valid do nothing if this char does not lie inside a column block no need to update line offset as columnblock column block would be rebuilt startingline starting line = innerparent inner parent startline start line endline end line = innerparent inner parent endline end line innerparent inner parent getchildren get children removeallelements remove all elements this line must have been retokenized and repainted by the bufferhandler buffer handler so repaint it again here after column blocks dirty status is updated }}} {{{ transactioncomplete transaction complete if we reach here use brute force as a last resolve }}} {{{ precontentinserted pre content inserted }}} {{{ precontentremoved pre content removed }}} 