{{{ imports }}} {{{ init }}} {{{ start }}} {{{ vfs v f s {{{ getfilevfs get v f s }}} {{{ geturlvfs get url v f s }}} {{{ getvfsforprotocol get v f s for protocol }}} {{{ getvfsforpath get v f s for path }}} {{{ getvfss get v f ss the sooner ppl move to the new api the less we'll need crap like this }}} }}} {{{ i/o i/ o request {{{ waitforrequests wait for requests }}} {{{ erroroccurred occurred }}} {{{ getrequestcount get request count }}} {{{ runinawtthread run in a w t thread }}} {{{ runinworkthread run in work thread }}} }}} {{{ }}} {{{ }}} {{{ sendvfsupdate send v f s update have to do this hack until vfspath v f s path is written don't send two updates for the same path we were the first to add an update add update sending runnable to a w t thread }}} {{{ sendvfsupdatessafely send v f s updates safely the vfs browser has what you might call a design flaw it doesn't update properly unless the vfs update for a parent arrives before any updates for the children sorting the list alphanumerically guarantees this }}} {{{ members {{{ variables an indicator of whether errordisplayer displayer is active should be accessed with synchronized errorlock lock }}} {{{ initializer }}} {{{ errordisplayer displayer preserve interruption flag but don't stop 2 threads might have been spawn simultaneously the loop breaks only when errors size == 0 we know that there are errors but let's wait a bit maybe there are more accumulating? we'll stay here until they stop coming out {{{ errors is a vector and vectors are synchronized we don't stop we have to display errors however the flag must be preserved but since someone breaks us let's exit this waiting loop }}} for a while new errors didn't appear let's display those which we already have while the dialog will be displayed there may arrive the next so we stay in the loop }}} }}} 