{{{ imports }}} {{{ tokenmarker token marker constructor }}} {{{ addruleset add rule set }}} {{{ getmainruleset get rule set }}} {{{ getruleset get rule set }}} {{{ getrulesets get rule sets }}} {{{ marktokens mark tokens {{{ set up some instance variables this is to avoid having to pass around lots and lots of }}} {{{ parser loop {{{ check if we have to stop parsing happens if the terminatechar terminate char has been exceeded }}} {{{ check for the escape rule before anything else }}} {{{ check for end of delegate }}} {{{ check every rule stop checking rules if there was a match }}} {{{ check if current character is a word separator }}} }}} {{{ mark all remaining characters }}} {{{ unwind any no_line_break parent delegates }}} /* for gc g c */ }}} {{{ members {{{ instance variables instead of passing these around to each we just store them as instance variables note that this is not thread safe }}} {{{ checkdelegateend check delegate end move pos to last character of match sequence }}} {{{ offsetmatches offset matches }}} {{{ handlerulestart handle rule start some rules can only match in certain locations see if the rule's start sequence matches here note that all regexps start with \a \ a so they only match the start of the matchstart match start = pos line offset /* workaround for hang if match was
				 * zero width not sure if there is
				 * a better way to handle this */ {{{ seq s e q a delegate d e l e g a t e attribute on a seq s e q changes the ruleset from the end of the seq s e q onwards }}} {{{ span s p a n eol_span /* substitute result of matching the rule start
				 * into the end 
				 *
				 * eg in shell script mode <<\s* \w+ is
				 * matched into \<$1\> to construct rules for
				 * highlighting read ins like this <<eof
				 << e o f
				 * 
				 * eof
				  e o f
				 */ }}} {{{ mark_following }}} {{{ mark_previous }}} move pos to last character of match sequence break out of inner for loop to check next char }}} {{{ handleruleend handle rule end some rules can only match in certain locations see if the rule's end sequence matches here this is used in checkdelegateend check delegate end escape rules are handled in handlerulestart handle rule start handle end of mark_following }}} {{{ handlenowordbreak handle no word break }}} {{{ handletokenwithspaces handle token with spaces }}} {{{ markkeyword mark keyword {{{ do digits only match against regexp if its not all digits if all digits no point matching mixed digit/alpha keyword and no regexp don't highlight as digit d i g i t }}} {{{ do keywords }}} {{{ handle any remaining crud }}} }}} {{{ substitute }}} {{{ matchtoken match token }}} {{{ checkhashstring check hash }}} }}} {{{ linecontext line context used for span_regexp rules otherwise {{{ linecontext line context constructor /*
			 * spans s p a ns with no delegate need to propagate the
			 * escape rule to the child context so this is
			 * needed 
			 */ }}} {{{ linecontext line context constructor }}} {{{ intern }}} {{{ hashcode hash }}} {{{ equals }}} {{{ clone }}} {{{ chararraysequal char arrays equal c1 is not }}} {{{ setinrule set in rule }}} }}} 