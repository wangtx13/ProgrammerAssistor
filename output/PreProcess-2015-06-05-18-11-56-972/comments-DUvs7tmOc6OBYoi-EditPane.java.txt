{{{ imports }}} {{{ getview get view }}} {{{ get textarea text area }}} {{{ getbuffer get buffer }}} {{{ setbuffer set buffer if buffer insidecompoundedit inside compound edit 	buffer endcompoundedit end compound edit when closing the last buffer of a bufferset buffer set the current buffer will still be the closed buffer until a new empty buffer is created so if the current buffer is not anymore in the bufferset buffer set do not set the recentbuffer recent buffer only do this if we are the current edit pane if the buffer is loading the caret info will be loaded on bufferupdate buffer update loaded l o a d e d otherwise we don't need to wait for io i o avoid a race condition see bug #834338 this must happen after loadcaretinfo load caret info otherwise caret is not restored properly }}} {{{ prevbuffer prev buffer }}} {{{ nextbuffer next buffer }}} {{{ recentbuffer recent buffer }}} {{{ focusontextarea focus on text area }}} {{{ gettextarea get text area }}} {{{ getbufferswitcher get buffer switcher }}} {{{ focusbufferswitcher focus buffer switcher }}} {{{ savecaretinfo save caret info }}} {{{ loadcaretinfo load caret info get our internal map of buffer > caretinfo caret info since there might be current info already set the position of the caret itself caret position could be stored in the internal map already if so use that one first otherwise fall back to any previously saved caret position that was stored in the buffer properties set any selections set firstline first line value set horizontal offset /* silly bug workaround #8694 if you look at the above 
		 * note that we restore the saved caret position first then
		 * scroll to the saved location however the caret changing
		 * can itself result in scrolling to a different location than
		 * what was saved and since movecaretposition move caret position calls
		 * updatebrackethighlight update bracket highlight the bracket highlight's out of
		 * bounds calculation will rely on a different set of physical
		 * first/last lines than what we will end up with eventually 
		 * instead of confusing the user with status messages that
		 * appear at random when switching buffers we simply hide the
		 * message altogether */ }}} {{{ bufferrenamed buffer renamed }}} {{{ caretinfo caret info }}} {{{ gotonextmarker go to next marker the markers list is not empty at this point }}} {{{ gotoprevmarker go to prev marker }}} {{{ gotomarker go to marker }}} {{{ addmarker add marker always add markers on selected lines toggle marker on caret line }}} {{{ swapmarkerandcaret swap marker and caret }}} {{{ handlepropertieschanged handle properties changed }}} {{{ getminimumsize get minimum size }}} {{{ getbufferset get buffer set }}} {{{ bufferadded buffer added it happens when having 1 untitled buffer if i open a the untitled buffer is closed but the new buffer is not yet opened }}} {{{ bufferremoved buffer removed the buffer was a new so i do not need to keep it's informations the closed buffer is the current buffer }}} {{{ buffermoved buffer moved }}} {{{ buffersetsorted buffer set sorted }}} {{{ tostring to }}} {{{ members {{{ editpane edit pane constructor do nothing if we have an editpane we copy it need to add the buffer to the bufferset buffer set it may not have been done by the setbuffer set buffer because the editpane edit pane is not yet known by jedit j edit and for view and global scope it is added through this list }}} {{{ close }}} }}} {{{ members {{{ instance variables a map of buffer getpath get path > caretinfo caret info this is necessary for when the same buffer is open in more than one editpane edit pane and the user is switching between buffers we want to keep the caret in the right position in each editpane edit pane which won't be the case if we just use the buffer caret property }}} {{{ propertieschanged properties changed left == default case set up the right click popup menu use old property name for backwards compatibility }}} {{{ initpainter init painter }}} {{{ loadbufferswitcher load buffer switcher }}} {{{ handlebufferupdate handle buffer update /* when closing the last buffer the bufferupdate buffer update closed
			  c l o s e d
			 * handler doesn't call setbuffer set buffer because buffers
			 * are not supported instead it waits for the subsequent
			 * 'untitled' ' untitled' creation */ since recentbuffer recent buffer will be set to the one that was closed the closed buffer is the current buffer the buffer was a new so i do not need to keep it's informations }}} }}} {{{ statushandler status handler }}} {{{ markerhighlight marker highlight {{{ getmarkerhighlightcolor get marker highlight color }}} {{{ setmarkerhighlightcolor set marker highlight color }}} {{{ ismarkerhighlightenabled is marker highlight enabled }}} {{{ ismarkerhighlightenabled is marker highlight enabled }}} {{{ paintvalidline paint valid line }}} {{{ gettooltiptext get tool tip text }}} }}} 