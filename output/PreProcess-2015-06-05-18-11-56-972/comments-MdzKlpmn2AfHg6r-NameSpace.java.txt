/*
 thanks to slava pestov of jedit j edit fame for caching enhancements 
 note this has gotten too big it should be broken down a bit 
*/ begin instance data note if we add something here we should reset it in the clear see notes in getthis get this /*
 note we will ll move this behavior out to a subclass of
 namespace name space but we'll start here 
 */ || getparent get parent !=null getparent get parent classstatic != end instance data begin constructors note in this case parent must have a manager we might want to do this here rather than explicitly in interpreter for global see also prune if classmanager manager == parent == create our own manager? register for notification of classloader change end constructors if localscoping switch follow strictjava strict else recurse /*recurse*/ primitives should have been wrapped {{{ jedit j edit change if value == 	throw new interpretererror interpreter variable value don't break jedit j edit core and plugins! }}} locate the variable definition if it found an existing variable here or above if recurse allowed no previous variable definition found here or above if recurse if recurse set global untyped var else set it here namespace name space varscope var scope = recurse ? getglobal get global this this modification makes default allocation local /*modifiers*/ namespacechanged name space changed on new variable addition /*
 note we need a singleton here so that things like 'this == this' work
 and probably a good idea for speed 

 caching a single instance here seems technically incorrect 
 considering the declaringinterpreter declaring interpreter could be different under some
 circumstances case a child interpreter running a source / eval 
 command however the effect is just that the interpreter that
 executes your script should be the one involved in call backs from 

 i do not know if there are corner cases where a child interpreter would
 be the first to use a this reference in a namespace or if that would
 even cause any problems if it did we could do some experiments
 to find out and if necessary we could cache on a per interpreter
 basis if we had weak references we might also look at skipping
 over child interpreters and going to the parent for the declaring
 interpreter so we'd be sure to get the top interpreter 
 */ /*interp*/ interpreter debug no manager namespace +this cut off from parent we must have our own manager can't do this in the run command needs to resolve stuff should we do it by default when we create a namespace will no parent of manager? xxx x x x if we keep the createclassmanager create manager in getclassmanager get manager then we can axe this? /*interp*/ if we are disconnected from root we need to handle the def imports change precedence if we are a body/instance get imported first change precedence if we are a body/instance try parent /*
 get variables declared in this namespace 
 */ checkvariablemodifiers check variable modifiers name modifiers setting a typed variable is always a local operation /*recurse*/ value is just a declaration note we might want to keep any existing value here instead of reset /*
 moved to variable
  variable
 if value == 
 value = primitive getdefaultvalue get default value type 
 */ does the variable already exist? is it typed? if it had a different type throw this allows declaring the same var again but not with a different even if assignable type else set it and careful here else fall through to override and install the new typed add the new typed var checkmethodmodifiers check modifiers {{{ jedit j edit properly handle with same signature is the new overriding the old method? check whether the new some old in the list }}} {{{ original beanshell bean shell if m == 	methods put name else if m instanceof bshmethod bsh { 	vector 	 vector v = new vector 	v addelement add element m 	v addelement add element 	methods put name v } else vector 	 vector m addelement add element }}} /*declaredonly*/ /*declared only*/ change precedence if we are a body/instance get first m contains either bshmethod bsh or vector of bshmethod bsh unwrap apply most specific signature matching try parent if it remove it and add it at the end avoid memory leak dots to slashes absolute remove trailing but preserve case of simple / if it remove it and add it at the end avoid memory leak {{{ jedit's j edit's getcommand get command /* chop leading / and change / to 
 classname name 
 if path equals / 
 classname name = name 
 else
 classname name = path substring 1 replace '/' ' ' + +name 

 clas = bcm classforname for name classname name 
 if clas != 
 clas */ /*
 getcommand get command 
 name argtypes arg types interpreter interpreter 
 utilevalerror
  eval error
 {
 if interpreter debug d e b u g interpreter debug getcommand get command +name 
 bshclassmanager bsh manager bcm = interpreter getclassmanager get manager 

 if importedcommands imported commands != 
 {
 loop backwards for precedence
 for i=importedcommands i=imported commands size 1 i>=0 i 
 {
 path = importedcommands imported commands elementat element at i 

 scriptpath script path 
 if path equals / 
 scriptpath script path = path + name + bsh 
 else
 scriptpath script path = path + / + name + bsh 

 interpreter debug searching for script +scriptpath +script path 

 inputstream input stream in = bcm getresourceasstream get resource as stream scriptpath script path 

 if in != 
 loadscriptedcommand load scripted command 
 in name argtypes arg types scriptpath script path interpreter 

 chop leading / and change / to 
 classname name 
 if path equals / 
 classname name = name 
 else
 classname name = path substring 1 replace '/' ' ' + +name 

 interpreter debug searching for +classname +class name 
 clas = bcm classforname for name classname name 
 if clas != 
 clas 
 }
 }

 if parent != 
 parent getcommand get command name argtypes arg types interpreter 
 else
 
 } */ }}} try imports /*onlystatic*/ /*only static*/ try imports /*onlystatic*/ /*only static*/ /*object*/ try imports /*onlystatic*/ /*only static*/ try imports /*onlystatic*/ /*only static*/ /*
 if we want to support multiple commands in the command path we need to
 change this to not throw the 
 */ /*
 here we catch any evalerror eval from the interpreter because we are
 using it as a tool to load the command not as part of the
 execution path 
 */ look for the loaded command /*
 if meth == 
 throw new utilevalerror eval loaded resource + resourcepath resource path +
 had an or did not contain the correct 
 */ cachecount++ cache count++ debug implement the recursion for getclassimpl get impl check the cache unqualified simple non compound name unqualified name check imported try imported if found as imported also cache it try absolute cache unqualified names to prevent check again not found try explicitly imported e g foo bar not sure if we should really recurse here for explicitly imported in parent /*
 found the full name in imported classes 
 */ try to make the full imported name handle imported inner case imported full name wasn't found as an absolute if it is compound try to resolve to an inner maybe this should happen in the bshclassmanager? bsh manager? /* not a */ if found cache the full name in the bshclassmanager bsh manager should we cache info in not a case too? it was explicitly imported but we don't know what it is should we throw an here?? /*
 try imported e g foo bar * 
 in reverse order of 
 give later imports precedence 
 */ /*
 try super if available
 note we do this last to allow explicitly imported classes
 and to take priority this will also throw an
 indicating ambiguity if it 
 */ /*
 for serialization 
 don't serialize non serializable 
 */ clear name resolvers don't know if this is necessary /*declaredonly*/ /*declared only*/ /*
 note this impor pattern is becoming common could factor it out into
 an importedobject imported vector 
 */ if it remove it and add it at the end avoid memory leak if it remove it and add it at the end avoid memory leak {{{ jedit j edit addition }}} 