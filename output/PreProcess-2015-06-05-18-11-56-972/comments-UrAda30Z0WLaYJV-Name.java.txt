/*
	<strong>implementation /*
	<strong> notes</strong>
	<pre>
	thread notes</strong>
	<pre>
	 thread safety all of the work in this must be synchronized
	because they share the internal intermediate evaluation state 

	note 

	 note about invokemethod we could simply use resolvemethod resolve and return
	the methodinvoker invoker bshmethod bsh or javamethod however there is no easy way
	for the ast a s t bshmehodinvocation b s h mehod invocation to use this as it doesn't have type
	information about the target to resolve overloaded 
	 in overloaded are resolved at compile time here they
	are of necessity dynamic so it would have to do what we do here
	and cache by signature we now do that for the client in reflect 

	note 

	 note on this caller resolution 
	although 
	 although references like these do work 

		this caller caller caller works

	the equivalent using successive calls 

		 does *not* work
		for caller=this caller caller != caller = caller caller 

	is prohibited by the restriction that you can only call caller on a 
	literal	this or caller reference the effect is that magic caller 
	reference only works through the current 'this' reference 
	the 
	 the real explanation is that this referernces do not really know anything
	about their depth on the call stack it might even be hard to define
	such a thing 

	for 

	 for those purposes we provide 

		this callstack

	</pre>
*/ these do not change during evaluation the following instance variables mutate during evaluation and should be reset by the reset where necessary for evaluation evalname and we're finished base for current eval number of times eval hit 'this caller' end mutable instance variables begin cached result structures these are optimizations note it's ok to cache resolution here because when the space changes the namespace will discard cached names end cached result structures i wish i could make this friendly to only namespace name space /*autoalloc*/ /*
			is /*
			 is it a simple variable name?
			doing name?
			 doing this first gives the correct precedence for vars 
			vs imported names at least in the simple case see
			tests/precedence1 bsh it should also speed things up a bit 
		*/ /*
			is /*
			 is it a bsh script variable reference?
			if reference?
			 if we're just starting the eval of name no base 
			or we're evaluating relative to a this type reference check 
		*/ switch namespace and special var visibility resolved the variable /*
			is /*
			 is it a name?
			if name?
			 if we're just starting eval of name try to make it else fail 
		*/ /*
				keep /*
				 keep adding parts until we have a 
			*/ not a or variable per above no variable or found in 'this' type ref if autoallocatethis auto allocate this then create one a child 'this' /*
			if /*
			 if we didn't find a or variable name or prefix above
			there are two possibilities 

			 if we are a simple name then we can pass as a variable 
			reference 
			 if we are compound then we must fail at this point 
		*/ /*
			 
			after 
			 after this point we're definitely evaluating relative to
			a base 
			 
		*/ /*
			do /*
			 do some basic validity checks 
		*/ previous round produced previous round produced /* 
			resolve 
			 resolve relative to a type
			static field inner ?
		*/ qualified 'this' reference from inner e g 'myouterclass ' my outer this' find the enclosing instance space of the name getclassinstance get instance if not there field? inner class? /*
			if /*
			 if we've fallen through here we are no longer resolving to
			a type 
		*/ /* 
			some 
			 some kind of field access?
		*/ length access on array? check for field on note could eliminate throwing the somehow /* not a field */ if we get here we have failed /*
				somewhat /*
				 somewhat of a hack if the special fields are visible we're
				operating relative to a 'this' type already dissallow further
				 this references to prevent user from skipping to things like
				super this caller
			*/ allow getthis get this to work through blocknamespace block name space to the namespace xxx x x x re eval this do we need it? /*
			some /*
			 some duplication for super see notes for this above
			if above
			 if we're in an enclsing instance and have a superclass
			instance our super is the superclass instance 
		*/ if specialfieldsvisible special fields visible throw new utilevalerror eval redundant to call this on this type allow getsuper get super to through blocknamespace block name space to the method's super super is now the closure's super or instance xxxx x x x x re evaluate this can getsuper get super work by itself now? if we're a instance and the parent is also a instance then super means our parent get the previous context see notes for this early get the previous context see notes for this is a instance if thisnamespace this name space classinstance instance != thisnamespace this name space getparent get parent classinstance instance != var means untyped /* try straightforward name first */ /* 
				try 
				 try toobject to which knows how to work through inner classes
				and see what we end up with 
			*/ interpreter and callstack references only resolution should not require them couldn't resolve it /*
	*/ should clean this up to a single statement simple non compound variable assignment e g x=5 interpreter debug simple var lhs l h s /*bubble up if allowed*/ field e g foo bar=5 /*forcclass*/ /*autoallocthis*/ finished eval and its a e g this x=5 or somethistype some this type x=5 dissallow assignment to magic fields /*
				if /*
				 if this was a literal super reference then we allow recursion
				in setting the variable to get the normal effect of finding the
				nearest definition starting at the super scope on any other
				resolution qualified by a 'this' type reference we want to set
				the variable directly in that scope e g this x=5 or 
				somethistype 
				some this type x=5 
				
				in 
				
				 in the old scoping rules super didn't do this 
			*/ optimization if classofstaticmethod of is set then we have already been here and determined that this is a invocation note maybe factor this out with path below clean up note if we want declared inside blocks to be accessible via this inside the block we could handle it here as a special case see also resolvethisfieldreference resolve this field reference special handling for blocknamespace block name space case they currently work via the direct name e g name superclass invocation? e g super foo allow getthis get this to work through block namespaces first find target or identifier if we've got an resolve the some other primitive should avoid calling on primitive as we do in name can't treat primitive like an message but the hole is useful right now found an and it's not an undefined variable it's a try cache the fact that this is a invocation on this ??? /*
		note /*
		 note the bsh command should probably not be here we need to
		scope it by the namespace that imported the command so it probably
		needs to be integrated into namespace name space 
	*/ /* reflecterror reflect invocationtargetexception*/ invocation target exception*/ check for existing if defined it look for a beanshell bean shell command should try to print usage here if nothing found look for a default handler in the namespace note this duplicates that in this should it? call on 'this' ' this' can never be a command /*
	private gethelp get help name 
		throws utilevalerror
	{
		try  eval error
	{
		try {
			 should check for namespace here
			return get bsh help +name null/interpreter/ 
		} catch e {
			return usage +name 
		}
	}

	private gethelp get help commandclass command 
		throws utilevalerror
	{
  eval error
	{
 try {
 reflect invokestaticmethod 
				null/bcm/ commandclass command usage 
 } catch e 
			return usage +name 
		}
	}
*/ that operate on compound ' ' separated names i guess we could move these to stringutil someday countparts count parts value > 1 end compound name routines 