{{{ imports }}} {{{ some constants }}} {{{ input/output {{{ reload }}} {{{ load view text areas temporarily blank out while a buffer is being loaded to indicate to the user that there is no data available yet only on initial load have to check again since above might set new_file flag {{{ do some stuff once loading is finished if the buffer is temporary we don't need to call finishloading finish loading because it sets the foldhandler fold handler and reload markers if reloading a clear dirty flag if loadautosave load autosave is we loaded an autosave so we set 'dirty' to note that we don't use setdirty set dirty because a that would send an unnecessary message b it would also set the autosave_dirty flag which will make the autosave thread write out a redundant autosave send some editbus edit bus messages editbus edit bus send new bufferupdate buffer update buffer this 	view bufferupdate buffer update markers_changed }}} }}} {{{ insertfile insert this if initial sanity checks if the is a directory etc fail }}} {{{ autosave }}} {{{ saveas save as files should have length 1 since the dialog type is save_dialog }}} {{{ save }}} {{{ save }}} {{{ save the is writeable but the vfs cannot do two stage we must overwrite readonly flag once save is complete do a few other things }}} {{{ checkfilestatus check status don't do these checks while a save is in progress because for a moment newmodtime new mod time will be greater than oldmodtime old mod time due to the multithreading only supported on local }}} }}} {{{ getters/setter for various buffer meta data {{{ getlastmodified get last modified }}} {{{ setlastmodified set last modified }}} {{{ getautoreload get auto reload }}} {{{ setautoreload set auto reload }}} 	 {{{ getiotask get io task 	public iotask io task getiotask get io task 	{ 		return iotask io task 	} }}} 	 {{{ setiotask set io task 	public setiotask set io task iotask io task task 	{ 		assert iotask io task == || iotask io task != iotask io task getstate get state == statevalue state value done d o n e 		this iotask io task = task 	} }}} {{{ getautoreloaddialog get auto reload dialog }}} {{{ setautoreloaddialog set auto reload dialog }}} {{{ getvfs get v f s }}} {{{ getautosavefile get autosave }}} {{{ removeautosavefile remove autosave }}} {{{ getname get name }}} {{{ getpath get path }}} {{{ getpath get path }}} {{{ getsymlinkpath get symlink path }}} {{{ getdirectory get directory }}} {{{ isclosed is closed }}} {{{ isloaded is loaded }}} {{{ isnewfile is new }}} {{{ setnewfile set new }}} {{{ isuntitled is untitled }}} {{{ setdirty set dirty }}} {{{ istemporary is temporary }}} {{{ geticon get icon }}} }}} {{{ property {{{ propertieschanged properties changed }}} {{{ getdefaultproperty get default property now try buffer <property> try returning it as an first }}} {{{ togglewordwrap toggle word wrap }}} {{{ toggleautoindent toggle auto indent {{{ togglelineseparator toggle line separator }}} {{{ getcontextsensitiveproperty get context sensitive property }}} }}} }}} {{{ edit modes syntax highlighting {{{ setmode set mode the context is not insensitive }}} }}} {{{ deprecated {{{ getfile get }}} }}} {{{ marker {{{ getmarkers get markers }}} {{{ getmarkerstatusprompt get marker status prompt }}} {{{ getmarkernamestring get marker name }}} {{{ addorremovemarker add or remove marker }}} {{{ addmarker add marker don't sort markers while buffer is being loaded }}} {{{ getmarkerinrange get marker in range }}} {{{ getmarkeratline get marker at line }}} {{{ removemarker remove marker }}} {{{ removeallmarkers remove all markers }}} {{{ getmarker get marker }}} {{{ getmarkerspath get markers path }}} {{{ updatemarkersfile update markers adapted from vfs v f s save }}} {{{ markerschanged markers changed }}} {{{ setmarkerschanged set markers changed }}} }}} {{{ miscellaneous {{{ setwaitsocket set wait socket }}} {{{ getnext get next }}} {{{ getprev get prev }}} {{{ getindex get index }}} {{{ tostring to }}} {{{ addbufferundolistener add buffer undo listener }}} {{{ removebufferundolistener remove buffer undo listener }}} }}} {{{ members {{{ buffer constructor this must be called before any editbus edit bus messages are sent /* magic untitled u n t i t l e d is only set if newfile new to
		 * constructor is set new_file is also set if file
		 * doesn't on disk 
		 *
		 * this is so that we can tell apart files created
		 * with jedit j edit newfile new and those that just don't
		 * on disk 
		 *
		 * why do we need to tell the difference between the
		 * two? jedit j edit addbuffertolist add buffer to list checks if the only
		 * opened buffer is an untitled buffer and if so 
		 * replaces it with the buffer to add we don't want
		 * this behavior to occur with files that don't
		 * on disk only untitled ones 
		 */ }}} {{{ committemporary commit temporary }}} {{{ close notify clients with wait log log log e r r o r this io }}} }}} {{{ members {{{ firebeginundo fire begin undo }}} {{{ fireendundo fire end undo }}} {{{ firebeginredo fire begin redo }}} {{{ fireendredo fire end redo }}} }}} {{{ members {{{ flags {{{ setflag set flag }}} {{{ getflag get flag }}} {{{ getflag get flag }}} {{{ flag values }}} }}} {{{ instance variables 	/** the current iotask io task of this buffer */ 	private volatile iotask io task iotask io task }}} {{{ setpath set path if we don't do this the autosave won't be deleted after a save as i wonder if the lack of this broke anything in the past? }}} {{{ recoverautosave recover autosave this might get called at startup show this message when all i/o i/ o requests are complete }}} {{{ checkfileforload check for load }}} {{{ checkfileforsave check for save }}} {{{ finishloading finish loading aha! a h a! this is probably the only way to fix this on a reload the fold handler doesn't change but we still need to re collapse folds don't do this on initial fold handler creation create marker positions }}} {{{ finishsaving finish saving {{{ set the buffer's path caveat won't work if save called with a relative path but i don't think anyone calls it like that anyway /* if we save a with the same name as one
				 * that's already open we presume that we can
				 * close the existing since the user
				 * would have confirmed the overwrite in the
				 * 'save as' dialog box anyway */ /* can't happen? */ /* if we saved over an already open using
				 * 'save a copy as' then reload the existing
				 * buffer */ /* can't happen? */ }}} {{{ update this buffer for the new path we do a write lock so that the autosave which grabs a read lock is not executed between the deletion of the autosave and clearing of the dirty flag if user adds mode buffer local property new message type introduced in 4 0pre4 }}} }}} }}} 