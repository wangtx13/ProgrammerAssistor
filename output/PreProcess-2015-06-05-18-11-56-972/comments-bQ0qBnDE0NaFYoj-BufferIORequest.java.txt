{{{ imports }}} {{{ constants }}} {{{ instance variables }}} {{{ bufferiorequest buffer i o request constructor buffer setiotask set io task this }}} {{{ tostring to }}} {{{ getchariobuffersize get char i o buffer size }}} {{{ getbyteiobuffersize get byte i o buffer size 2 is sizeof char in byte }}} {{{ autodetect }}} {{{ read /* we guess an initial size for the */ only if the size is known if the size is not known start with a resonable default buffer size /* number of characters in 'buf' 
		 inputstream input stream read doesn't always fill the
		 eg the size is not a multiple of
		 iobufsize i o b u f s i z e or it is a gzipped g zipped etc */ if a \n was read after a \r usually means this is a dos/windows d o s/ windows a \r was read hence a macos mac o s was the previous read character a \r? if we read a \n and this is we assume we have a dos/windows d o s/ windows number of lines read every 100 lines we update the progress bar offset of previous line relative to the start of the i/o i/ o buffer not n o t relative to the start of the document look for line endings if we read a \r and lastwascr last was c r is also it is probably a mac \r\r in stream otherwise set a flag so that \n knows that last was a \r insert a line this is i+1 to take the trailing \n into account /* if lastwascr last was c r is we just read a \r followed
					 by a \n we specify that this is a windows 
					 but take no further action and just ignore the \r */ /* bump lastline last line so that the next line doesn't erronously
						 pick up the \r */ /* otherwise we found a \n that follows some other
					 * character hence we have a unix */ /* if we find some other character that follows
					 a \r so it is not a windows and probably
					 a mac */ add remaining stuff from buffer fix for 865589 0 byte files should open using the default line seperator chop trailing newline and/or ^z ^ z if any /* dos d o s ^z ^ z */ add a line marker at the end for proper offset manager operation to avoid having to deal with read/write locks and such we insert the loaded data into the buffer in the post load cleanup runnable which runs in the a w t thread used in insert }}} {{{ write }}} {{{ members {{{ createencodingerrormessage create encoding message column the character ignore }}} {{{ getfirstguiltycharacterindex get first guilty character index look for the first character which causes encoding }}} }}} 