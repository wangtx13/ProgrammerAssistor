{{{ imports }}} {{{ chunkcache chunk cache constructor }}} {{{ getmaxhorizontalscrollwidth get max horizontal scroll width }}} {{{ getscreenlineofoffset get screen line of offset find the screen line containing this offset line is invisible? 1 }}} {{{ recalculatevisiblelines recalculate visible lines }}} {{{ setbuffer set buffer }}} {{{ scrolldown scroll down }}} {{{ scrollup scroll up don't try this at home }}} {{{ invalidateall invalidate all }}} {{{ invalidatechunksfromphys invalidate chunks from phys }}} {{{ getlineinfo get line info }}} {{{ getlinesubregioncount get line subregion count }}} {{{ getsubregionofoffset get subregion of offset }}} {{{ xtosubregionoffset x to subregion offset }}} {{{ xtosubregionoffset x to subregion offset }}} {{{ subregionoffsettox subregion offset to x }}} {{{ subregionoffsettox subregion offset to x }}} {{{ getsubregionstartoffset get subregion start offset }}} {{{ getsubregionendoffset get subregion end offset }}} {{{ getbelowposition get below position }}} {{{ getaboveposition get above position }}} {{{ needfullrepaint need full repaint }}} {{{ getlineinfosforphysicalline get line infos for physical line }}} {{{ members {{{ instance variables }}} {{{ getlineinfosforphysicalline get line infos for physical line }}} {{{ getfirstscreenline get first screen line }}} {{{ getupdatestartline get update start line for the first line displayed take its physical line to be the text area's first physical line otherwise determine the next visible line if 1 the empty space at the end of the text area when the buffer has less lines than are visible }}} {{{ updatechunksupto update chunks up to this is a nightmare if one line's chunks are invalid remaining lines are also invalid i e if the lastscreenline last screen line is smaller as the first invalid screen line we don't need to update the chunks leave here below comment is not any more at least partly note that we rely on the fact that when a physical line is invalidated all screen lines/subregions of that line are invalidated as well see below comment for that tries to uphold this assumption get another line of chunks unless this is the first time increment the line number empty space fix the bug where the horiz scroll bar was not updated after creating a new chunk the line if the line has no text out size == 0 otherwise the number of subregions fixme f i x m e i == 0 !? not i == firstline first line ? the skew cannot be greater than the chunk count of the line we need at least one chunk per subregion in a line /* if the user changes the syntax token at the
				 * end of a line need to do a full repaint */ /* if this line has become longer or shorter
				 * in which case the new physical line number
				 * is different from the cached one we need to 
				 * continue updating past the last line
				 * advise the text area to repaint
				 * on the other hand if the line wraps beyond
				 * lastscreenline last screen line we need to keep updating the
				 * chunk list to ensure proper alignment of
				 * invalidation flags see start of */ /* we only cache entire physical lines at once 
				 * don't want to split a physical line into
				 * screen lines and only have some valid */ }}} {{{ linetochunklist line to chunk list }}} }}} {{{ lineinfo line info }}} 