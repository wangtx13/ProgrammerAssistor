{{{ boyermooresearchmatcher boyer moore search matcher constructors }}} {{{ nextmatch next match match == returnvalue value or }}} {{{ match {{{ lazily create skip and suffix arrays for either the search pattern or the reversed search pattern }}} position variable for pattern test position position variable for pattern start last possible start position of a match with this pattern this is negative if the pattern is longer than the text causing the search loop below to immediately fail last_anchor = reversesearch reverse search 	? offset + pattern length 1 	 length pattern length the search works by starting the anchor first character of the pattern at the initial offset as as the anchor is far enough from the enough of the text for the pattern to match and until the pattern matches we compare the pattern to the text from the last character to the first character in reverse order where a character in the pattern mismatches we use the two heuristics based on the mismatch character and its position in the pattern to determine the furthest we can move the anchor without missing any potential pattern matches pattern test character mismatch determine how many characters to skip heuristic #1 heuristic #2 skip the greater of the two distances provided by the heuristics go back to the while loop match m a t c h the position of its first character mismatch m i s m a t c h 1 as defined by api a p i }}} {{{ tostring to }}} {{{ members boyer moore member fields boyer moore helper {{{ generateskiparray generate skip /*
	 * the 'skip' is used to determine for each index in the
	 * hashed alphabet how many characters can be skipped if
	 * a mismatch occurs on a characater hashing to that index 
	 */ initialize the skip to all zeros leave the table cleanly initialized for an empty pattern }}} {{{ getskipindex get skip index /*
	 * to avoid our skip table having a length of 2 ^ 16 we hash each
	 * character of the input into a character in the alphabet \x00 \xff \x f f 
	 * using the lower 8 bits of the character's value resulting in
	 * a more reasonable skip table of length 2 ^ 8 
	 *
	 * the result of this is that more than one character can hash to the
	 * same index but since the skip table encodes the position of
	 * occurence of the character furthest into the with a particular
	 * index whether or not it is the only character with that index an
	 * index collision only means that that this heuristic will give a
	 * sub optimal skip i e a complete skip table could use the differences
	 * between colliding characters to maximal effect at the expense of
	 * building a table that is over 2 orders of magnitude larger and very
	 * sparse 
	 */ }}} {{{ generatesuffixarray generate suffix /*
	 * xxx x x x hairy that is basically just a functional ? port of some
	 * other i barely understood
	 */ the above builds a 1 indexed suffix but we shift it to be 0 indexed ignoring the original 0 th element }}} }}} 