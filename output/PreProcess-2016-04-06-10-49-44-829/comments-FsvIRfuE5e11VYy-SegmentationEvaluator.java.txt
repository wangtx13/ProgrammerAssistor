equals is called on these to determine if this token is the start end of a segment segmentendtag segment end tag should for the token *after* the end of the segment i e that token is not part of the segment pattern endregex end regex = pattern compile ^o ^ o * tokens = if instance getsource get source != tokens = instance getsource get source tostring to stringbuffer buffer sb = new stringbuffer buffer sb append tokens charat char at j here these actually mean end not start it is a correct segment if hashfile hash alllexicons all lexicons contains sb tostring to numcorrectsegmentsinalphabet++ num correct segments in alphabet++ else numcorrectsegmentsoov++ num correct segments o o v++ it is an incorrect segment let's find out if it was in the lexicon for mm = m mm < trueoutput output size mm++ { if segmentendtag segment end tag equals predoutput pred output get mm break sb append tokens charat char at mm } if hashfile hash alllexicons all lexicons contains sb tostring to numincorrectsegmentsinalphabet++ num incorrect segments in alphabet++ else numincorrectsegmentsoov++ num incorrect segments o o v++ sb append tokens charat char at m for the case of the end of the sequence if hashfile hash alllexicons all lexicons contains sb tostring to numcorrectsegmentsinalphabet++ num correct segments in alphabet++ else numcorrectsegmentsoov++ num correct segments o o v++ if hashfile hash alllexicons all lexicons contains sb tostring to numincorrectsegmentsinalphabet++ num incorrect segments in alphabet++ else numincorrectsegmentsoov++ num incorrect segments o o v++ here is an incorrect predicted start find out if the word is in the lexicon stringbuffer buffer sb = new stringbuffer buffer sb append tokens charat char at j for mm = j+1 mm < trueoutput output size mm++ { if segmentendtag segment end tag equals predoutput pred output get mm break sb append tokens charat char at mm } if hashfile hash alllexicons all lexicons contains sb tostring to numincorrectsegmentsinalphabet++ num incorrect segments in alphabet++ else numincorrectsegmentsoov++ num incorrect segments o o v++ out correct segments oov= o o v= +numcorrectsegmentsoov+ +num correct segments o o v+ iv= i v= +numcorrectsegmentsinalphabet +num correct segments in alphabet out incorrect segments oov= o o v= +numincorrectsegmentsoov+ +num incorrect segments o o v+ iv= i v= +numincorrectsegmentsinalphabet +num incorrect segments in alphabet 