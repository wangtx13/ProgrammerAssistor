cc mallet random only used for logjoint log joint test for now bruteforceinferencer brute force inferencer 	 variableelimination variable elimination add all variables to model add some links pots = new { { rescale r nextdouble next scale d into range 0 2 0 8 if vars i has no edge potential add a node potential to keep things simple we'll require the potential to be normalized ensure exactly one connected component add some random edges ensure exactly one connected component these models are all small so that we can run the brute force inferencer on them for mdlidx mdl idx = 0 mdlidx mdl idx < models length mdlidx++ mdl idx++ { loopybp loopy b p only handles edge ptls continue loopybp loopy b p only handles edge ptls continue /* ensure that lookuplogjoint lookup log joint consistent */ brute force varelim var elim doesn't compute log joints let it slide /* query every known graph with every known alg */ /* now make sure the exact marginals are consistent for
 * the same model */ by the time we get here a joint is only if there was an unsupportedoperationexception unsupported operation compare all approximate algorithms against brute force brute force loopybp loopy b p does not support vertex potentials we'll let that slide /* lookup all marginals */ add a few that don't fit allow unsupported inference to slide with warning trp can't handle disconnected models which arise during query be careful that caching of inference algorithms does not affect results here copy the inferencer before calling b/c of random seed issues this is really impossible after the change to the factor graph representation tests the measurement of numbers of messages sent 				asserttrue 				assert maths almostequals almost equals prob1 prob2 check joint 		discretepotential 		 discrete potential joint = brute joint model check all marginals out marg1 out marg2 for each assignment to the model check that trp t r p lookuplogjoint lookup log joint and trp t r p lookupjoint lookup joint are consistent hard to do automatically right now ensure that all edges touched works verify that variable indices are consistent in undirectected models tests that trp t r p and max product propagation the same results when trp t r p runs for exactly one iteration trp t r p should same results as viterbi trp t r p should same results as viterbi tests that trp t r p and max product propagation the same results when trp t r p is allowed to run to convergence trp t r p should same results as viterbi /*
 testmm test m m exception
  exception
 {
 testquery test query 
 testtreeviterbi test tree viterbi 
 testtrpviterbiequiv test trp viterbi equiv 
 testtrpviterbiequiv2 test trp viterbi equiv2 
 testmaxmarginals test max marginals 
 }
 */ xxx fails because of trp t r p termination i e always succeeds if termination is iterationtermination iteration termination 10 but usually fails if termination is defaultconvergenceterminator default convergence terminator 1e 12 1000 something about selection of random spanning trees??? { mdlidx mdl idx = 4 if mdlidx mdl idx != 3 { visualizer showmodel show model mdl mdl dump out ***end *** e n d mdl m d l +mdlidx+ +mdl idx+ *** } foo = currenttimemillis current time millis out foo out mdl eventially this should be folded into testmarginals test marginals testjoint test joint etc /* todo t o d o not sure how to test this anymore 
	 test multiplication of potentials where variables are in
	 a different order
	public testmultiplication2 test multiplication2 
	{
		variable 
	{
		 variable vars = new variable {
			new variable 2 
			new variable 2 
		} 
		double probs1 = new { 2 4 1 6 } 
		double probs2a = new { 3 7 6 5 } 
		double probs2b = new { 3 6 7 5 } 

		multinomialpotential 

		 multinomial potential ptl1a = new multinomialpotential multinomial potential vars probs1 
		multinomialpotential 
		 multinomial potential ptl1b = new multinomialpotential multinomial potential vars probs1 
		multinomialpotential 
		 multinomial potential ptl2a = new multinomialpotential multinomial potential vars probs2a 

		variable 

		 variable vars2 = new variable { vars 1 vars 0 } 
		multinomialpotential 
		 multinomial potential ptl2b = new multinomialpotential multinomial potential vars2 probs2b 

		ptl1a multiplyby multiply by ptl2a 
		ptl1b multiplyby multiply by ptl2b 
		
		asserttrue 
		
		assert ptl1a almostequals almost equals ptl1b 
	}
 */ 			system 			 out summing +v1+ + +v2 below should be except potentials have different ranges asserttrue assert bp lookupmarginal lookup marginal vars 1 almostequals almost equals bp lookupmarginal lookup marginal vars 2 clear all caches asserttrue assert diff2 < diff1 previously unsupportedoperationexception unsupported operation exptected default to lookupmarginal lookup marginal variable for clique of size 1 eventually this should be moved to models but trp t r p currently chokes on disconnected model using this for profiling confuse the inferencer make sure we have cached correct results note that we can't use an epsilon here that's less than our convergence criteria undirectedmodel undirected model mdl = randomgraphs random graphs createuniformchain create uniform chain 800 undirectedmodel undirected model mdl = randomgraphs random graphs createuniformchain create uniform chain 800 /*
 testbpdualedgefactor test bp dual edge factor 
 {
 variable vars = new variable {
 new variable 2 
 new variable 2 
 new variable 2 
 new variable 2 
 } 

 random r = new random 
 factor tbl1 = createedgeptl create edge ptl vars 0 vars 1 r 
 factor tbl2a = createedgeptl create edge ptl vars 1 vars 2 r 
 factor tbl2b = createedgeptl create edge ptl vars 1 vars 2 r 
 factor tbl3 = createedgeptl create edge ptl vars 2 vars 3 r 

 factorgraph factor graph fg = new factorgraph factor graph vars 
 fg addfactor add factor tbl1 
 fg addfactor add factor tbl2a 
 fg addfactor add factor tbl2b 
 fg addfactor add factor tbl3 

 inferencer inf = new trp t r p 
 inf computemarginals compute marginals fg 

 varset var set vs = tbl2a varset var set 
 factor marg1 = inf lookupmarginal lookup marginal vs 

 factor prod = tablefactor table factor multiplyall multiply all fg factors 
 factor marg2 = prod marginalize vs 
 marg2 normalize 

 asserttrue assert factors not equal! bp b p +marg1 dumptostring dump to + \n exact e x a c t +marg2 dumptostring dump to marg1 almostequals almost equals marg2 
 }
 */ 