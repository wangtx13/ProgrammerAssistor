{ logger setlevel set level level info i n f o } position of input used to enter this node transducer state from which this node entered transducer output produced on entering this node the one required by astarstate a star state required by searchstate search state super of astarstate a star state no cache for this position 			system 			 out cache + numcaches num caches + / + maxcaches max caches create another cache steal least used cache move to front this initializes the forward path but does not yet do the backward pass viterbi forward gsc removing unnecessary cast commented out so we get the start state viterbinode viterbi node akm 12/2007 ans = ans getparent get parent ans now corresponds to the viterbi node after the first transition was == j+1 ensure that viterbinodealignmentcache viterbi node alignment cache has at least size n here is where we grab the state from the viterbinode viterbi node ensure that viterbinodealignmentcache viterbi node alignment cache has at least size n here is where we grab the output from the viterbinode viterbi node destination ensure that outputalignmentcache output alignment cache has at least size n todo t o d o consider caching this result we are only going to increment along the single best path get 0 below we could consider having a of this incrementtransducer increment transducer transducer incrementor incrementor counts where the number of n best paths to increment would be determined by counts length not sure this works for unequal input/output lengths increment the initial state increment the state xxx this assumes that a transition is completely identified and made unique by its destination state and output this may not be true! logger fine tokenaccuracy token accuracy ref +referenceoutput +reference output get i + viterbi +output get i logger fine tokenaccuracy token accuracy ref +referenceoutput +reference output get i + viterbi +output get i 