add wrong wrongs after 5 iterations reports joint likelihood of estimated on the training set /* vectors that contain the counts of features observed in the
 training data maps
  maps
 clique template x feature number => count
 */ /* vectors that contain the expected value over the
 * labels of all the features have seen the training data
 * but not the training labels 
 */ /* initialize constraints and expectations 
 * to have the same dimensions as weights but to
 * be all zero 
 */ do the defaults first and now the others /* allocate for weights constraints and expectations */ /*
	if cacheunrolledgraphs cache unrolled graphs {
	unrolledgraphs {
	unrolled graphs = new unrolledgraph unrolled graph numinstances num instances 
	}
*/ /* negate initialvalue initial value and finalvalue value because the are in
 * terms of weights not values 
 */ functions for unit tests to get constraints and expectations i'm too lazy to make a deep copy callers should not modify these /* instance values must either always or never be included in
 * the total values we can't just sometimes skip a value
 * because it is infinite that off the total values 
 * we only allow an instance to have infinite value if it happens
 * from the start we don't compute the value for the instance
 * after the first round if any other instance has infinite
 * value after that it is an */ /* we could initialize bitset with one slot for every
 * instance but it is *probably* cheaper not to taking the
 * time hit to allocate the space if a bit becomes
 * necessary */ /* clear the sufficient statistics that we are about to fill */ /* fill in expectations for each instance */ /* compute marginals for each clique */ acrf a c r f unrolledgraph unrolled graph unrolled = new acrf a c r f unrolledgraph unrolled graph instance templates arrays aslist as list fixedtmpls fixed tmpls if unrolled numvariables num variables == 0 continue happens if all nodes are pruned /* save the expected value of each feature for when we
 compute the gradient */ continue /*
						printdebuginfo /*
						print debug info unrolled 
						throw new illegalstateexception
							  illegal state exception
							 instance + instance getname get name + used to have non infinite 
							 + value but now it has infinite value 
*/ /*					throw new illegalstateexception
						  illegal state exception
						 value is nan na n in acrf a c r f getvalue get value instance +i 
*/ /* incorporate gaussian prior on this means
 that for each weight we will add w^2 / 2 * variance to the
 log probability */ /* index into current element of cachedgradient cached gradient */ first do gradient wrt defaultweights default weights now do other weights computed below /* a parameter may be set to infinity by an external user 
 * we set gradient to 0 because the parameter's value can
 * never change anyway and it will mess up future calculations
 * on the matrix */ out computing for ww w w +clique+ idx +ww assnidx+ assn idx+ target +target constraints for wrong wrongs for instance wrong w r o n g wrong w r o n g handling h a n d l i n g if !acrf iscacheunrolledgraphs is cache unrolled graphs { throw new illegalstateexception illegal state wrong wrong won't work without caching unrolled graphs } out computing for ww w w +vs+ idx +assnidx+ +assn idx+ target +var optimizableacrf optimizable a c r f 