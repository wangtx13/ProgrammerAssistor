brents using derivative information p405 numeric recipes in c /*
	public maximize optimizable function matrix line initialstep initial step {
		return maximize optimizable bygradient by gradient function line initialstep initial step 
	}*/ todo t o d o this seems to work but is slower than backtracklinesearch back track line search why? the last step size used line should point in the direction we want to move the to get higher value a=left b=center c=right t=test steps domain these are deltas from initial params! costs range projected gradients the x step of the last function call make sure search line points upward logger info initial gradient = +tg find an cx value where the gradient points the other way then we will know that the local zero gradient minimum falls in between ax and cx if we are still looking to cross the minimum move ax towards it save this possibly middle point it might make an acceptable bx sometimes the suggested initialstep initial step is very large and causes values to go to infinity tx = initialstep initial step tx = 1 0 logger info gradient cross over search incrementing by + tx ox logger info next gradient = +tg err iterations + total iterations in a logger info after gradient cross over ax= +ax+ bx= +bx+ cx= +cx logger info after gradient cross over ay= +ay+ by= +by+ cy= +cy logger info after gradient cross over ag= +ag+ bg= +bg+ cg= +cg we need to find a by that is less than both ay and cy last condition would happen if we did first while loop only once xxx what should this tolerance be? xxx i'm nervous that this is masking some assert s below that were previously failing if they were failing due to round off that's ok o k but if not if math abs bg < 10 || math abs ay by < 1 || math abs by cy < 1 bx != ax magically we are done instead make a that finds the interpolating point by fitting a parabola and then jumps to that minimum if the actual y value is within tolerance of the parabola fit's guess then we are done otherwise use the parabola's x to split the region and try again there might be some cases where this will perform worse than simply bisecting as we do now when the function is not at all parabola shaped if the gradients ag and bg point in the same direction then the value by must be less than ay and vice versa for bg and cg assert ax==bx || ag*bg >=0 by>ay || bg*cg >=0 by>cy the minimum is at higher x values than bx drop ax the minimum is at lower x values than bx drop cx find a new mid point logger info minimum bx search incrementing by + bx ox logger info during min bx search +iterations+ ax= +ax+ bx= +bx+ cx= +cx logger info during min bx search +iterations+ ay= +ay+ by= +by+ cy= +cy logger info during min bx search +iterations+ ag= +ag+ bg= +bg+ cg= +cg we now have two points ax cx that straddle the minimum and a mid point bx with a value lower than either ay or cy logger info ending ax= +ax+ bx= +bx+ cx= +cx+ tx= +tx logger info ending ay= +ay+ by= +by+ cy= +cy assert function getvalue get value >= origy orig y as a suggestion for the next initalstep inital step the distance from our initialstep initial step to the minimum we found err iterations + total iterations in b exit 0 