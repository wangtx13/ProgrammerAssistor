****************************************************************************** cpal c p a l new n e w beam b e a m of forward backward ****************************************************************************** cpal c p a l like lattice but using max product to get the viterbipath viterbi path cpal c p a l these worked well for nettalk beamwidth beam width = 10 kleps k leps = 005 the number of times we have been called this iteration ip == input position op == output position i == state index indexed by ip i cpal c p a l can be adapted if maximizer is confused xxx now that we are incrementing here directly there isn't necessarily a need to save all these arrays log probability of being in state i at input position ip indexed by ip i indexed by ip i j saved only if savexis save xis is indexed by op created only if outputalphabet output alphabet is non in constructor you may pass for output meaning that the lattice is not constrained to match the output you may pass for output meaning that the lattice is not constrained to match the output if outputalphabet output alphabet is non this will create a labelvector label vector for each position in the output sequence indicating the probability distribution over possible outputs at that time index initialize some structures xxx not very efficient when the lattice is actually sparse especially when the number of states is large and the sequence is xxx yipes this could get big something sparse might be better? forward pass out forward pass initialweight initial weight = +initialweight +initial weight out nodes 0 i alpha= +nodes 0 i alpha cpal c p a l a sorted list for our beam experiments cpal c p a l used for stats cpal c p a l used to adapt beam if optimizer is getting confused tctiter++ tct iter++ curbeamwidth cur beam width = math min math round curavgnstatesexpl*2 cur avg nstates expl*2 numstates num states out doubling minimum beam size to +curbeamwidth +cur beam width ************************************************************ cpal c p a l add this to construct the beam *************************************************** cpal c p a l sets up the sorted list cpal c p a l set the state s = t getstate get state i cpal c p a l give the nb n b viterbi node the weight position cpal c p a l unlike std n best beam we now filter the list based on a kl k l divergence like measure *************************************************** use which computes the cumulative log sum and finds the point at which the sum is within kleps k leps trick negative values for kleps k leps mean use the max of kl k l an rmin rminpos rmin pos = slists ip getthrpos get t h rpos out nstatesexpl nstates expl ip + cpal c p a l contemplating setting values to something else is faster and seems to work the same done contemplation for i = 0 i < numstates num states i++ { cpal c p a l dont need this anymore should be taken care of in the lists if nodes ip i == || nodes ip i alpha == transducer impossible_weight xxx if we end up doing this a lot we could save a list of the non ones 	continue out destinationnode destination node alpha < +destinationnode +destination node alpha out mean nodes explored + matrixops matrix ops mean nstatesexpl nstates expl calculate total cost of lattice this is the normalizer note actually we could sum at any ip index the choice of latticelength lattice length 1 is arbitrary out ending alpha state +i+ = +nodes latticelength lattice length 1 i alpha out ending beta state +i+ = +t getstate get state i finalweight weight weight is now an unnormalized weight of the entire lattice assert weight >= 0 weight = +weight if the sequence has infinite weight just usefully this avoids calling any incrementx increment x it also relies on the fact that the gammas and alpha and beta values are already initialized to values that reflect infinite weight xxx although perhaps not all alphas betas exactly correctly reflecting? backward pass note that skipping here based on alpha means that beta values won't be correct but since alpha is infinite anyway it shouldn't matter 							assert transitionweight transition weight >= 0 not necessarily xxx this assumes that ip == op ! out crf c r f lattice outputcounts output counts +ip+ +outputindex+ +output index+ += +p cpal c p a l check the normalization note actually we could sum at any ip index the choice of latticelength lattice length 1 is arbitrary out ending alpha state +i+ = +nodes latticelength lattice length 1 i alpha out ending beta state +i+ = +t getstate get state i finalweight weight out check gamma sum= +checknorm cpal c p a l done check of normalization cpal c p a l normalize out check gamma sum= +checknorm cpal c p a l normalization cpal c p a l a simple node holding a weight and position of the state minc = lc1 lc2 mincthr minc t h r = minc minc*rmin minc* rmin kleps k leps = 0 1 note n o t e sometimes we can have positive numbers ! lc = tn weight worstc if lc >0 { asdf=1 } normalize cpal c p a l if the list is too big remove the first largest weight element f = o totalweight total weight o nextbeststateindex next best state index atend at end = for i=0 i<list size i++ { 	asearchnode_nbest tempnode temp node = asearchnode_nbest list get i 	double f1 = tempnode temp node totalweight total weight tempnode temp node nextbeststateindex next best state index 	if f < f1 { 		list add i o 		atend 		at end = 		break 	} } if atend at end list add o cpal c p a l end nbestslist n best slist 	culotta for constrained lattice constraints tells the lattice which states must emit which observations positive values say all paths must pass through this state index negative values say all paths must _not_ pass through this state index 0 means we don't care initialize to 0 include 1 extra node for start state 			throw new illegalargumentexception illegal argument could not find state + constrainedsequence constrained sequence get i + check that state labels match starttags start tags and intags in tags set additional negative constraint to ensure state after segment is not a continue tag xxx if segment length=1 this actually constrains the sequence to b tag b tag ' instead of the intended constraint of b tag i tag ' the fix below is unsafe but will have to do for now fixed f i x e d below b e l o w /*		string /*		 endtag end tag = constrainedsequence constrained sequence get requiredsegment required segment getend get end 
				if requiredsegment required segment getend get end +2 < constraints length {
					if requiredsegment required segment getstart get start == requiredsegment required segment getend get end { segment has length 1
						if endtag end tag startswith starts with b {
							endtag {
							end tag = i + endtag end tag substring 1 endtag end tag length 
						}
						else if ! endtag end tag startswith starts with i || endtag end tag startswith starts with 0 
							throw new illegalargumentexception illegal argument constrained lattice requires that states are tagged in b i o format 
					}
					int statei = stateindexofstring state index of endtag end tag 
					if statei == 1 no i tag for this b tag
						statei = stateindexofstring state index of constrainedsequence constrained sequence get requiredsegment required segment getstart get start 
					constraints requiredsegment required segment getend get end + 2 = statei + 1 
				}
		 */ if 		printstates 		print states culotta constructor for constrained lattice initialize some structures xxx not very efficient when the lattice is actually sparse especially when the number of states is large and the sequence is xxx yipes this could get big something sparse might be better? xxx move this to an ivar so we can save it? but for what? commenting this out because it's a memory hog and not used right now uncomment and conditionalize under a flag if ever needed cas xis = new latticelength lattice length numstates num states numstates num states /* commenting out xis cas
			for j = 0 j < numstates num states j++ 
				for ip = 0 ip < latticelength lattice length ip++ 
					xis ip i j = transducer impossible_weight 
			 */ forward pass ensure that at least one state has initial weight less than infinity so we can start from there out forward pass initialweight initial weight = +initialweight +initial weight out nodes 0 i alpha= +nodes 0 i alpha check if this node is possible at this <position label> if not skip it must be in state indexed by constraints ip 1 must _not_ be in state indexed by constraints ip xxx if we end up doing this a lot we could save a list of the non ones check constraints to see if node at <ip i> can transition to destination if logger isloggable is loggable level fine f i n e out destinationnode destination node alpha < +destinationnode +destination node alpha this is an illegal transition according to our constraints so set its prob to 0 no n o alpha's are unnormalized weights set to inf destinationnode destination node alpha = 0 0 						destinationnode 						destination node alpha = transducer impossible_weight calculate total weight of lattice this is the normalizer note actually we could sum at any ip index the choice of latticelength lattice length 1 is arbitrary out ending alpha state +i+ = +nodes latticelength lattice length 1 i alpha out ending beta state +i+ = +t getstate get state i finalweight weight weight is now an unnormalized weight of the entire lattice assert weight >= 0 weight = +weight if the sequence has infinite weight just usefully this avoids calling any incrementx increment x it also relies on the fact that the gammas and alpha and beta values are already initialized to values that reflect infinite weight xxx although perhaps not all alphas betas exactly correctly reflecting? backward pass note that skipping here based on alpha means that beta values won't be correct but since alpha is infinite anyway it shouldn't matter 							assert transitionweight transition weight >= 0 not necessarily xis ip i j = nodes ip i alpha + transitionweight transition weight + nodes ip+1 j beta weight xxx this assumes that ip == op ! out crf c r f lattice outputcounts output counts +ip+ +outputindex+ +output index+ += +p no this weight is an unnormalized weight getprobability get probability { math exp weight } a container for some information about a particular input position and state outputposition output position not really needed until we deal with asymmetric epsilon xxx remove this check 