{logger setlevel set level level fine f i n e } variables acting as default values for the correspondingly named instance variables can be overridden sort of like named like this sumlattice sum lattice lattice = new sumlatticedefault sum lattice default transducer input {{ savexis=true save xis=true }} ip == input position op == output position i == state index indexed by ip i indexed by ip i indexed by ip i j saved only if savexis save xis is indexed by op created only if outputalphabet output alphabet is non in constructor ensure that instances cannot easily be created by a zero arg constructor initialize some structures xxx not very efficient when the lattice is actually sparse especially when the number of states is large and the sequence is xxx yipes this could get big something sparse might be better? forward pass out forward pass initialcost initial cost = +initialcost +initial cost out nodes 0 i alpha= +nodes 0 i alpha xxx if we end up doing this a lot we could save a list of the non ones out destinationnode destination node alpha < +destinationnode +destination node alpha calculate total weight of lattice this is the normalizer out ending alpha state +i+ = +nodes latticelength lattice length 1 i alpha out ending beta state +i+ = +t getstate get state i getfinalweight get weight totalweight total weight is now an unnormalized weight of the entire lattice if the sequence has infinite weight just usefully this avoids calling any incrementx increment x it also relies on the fact that the gammas and alpha but not beta values are already initialized to values that reflect infinite weight todo t o d o is it important to fill in the betas before we return? backward pass gsc reducing from 1e 10 to 1e 6 gsc removing the isnan is na n check range check will catch the nan na n as well assert p >= 0 0 p <= 1 0+1e 10 !double ! isnan is na n p p= +p+ gamma= +gammas latticelength lattice length 1 i note that skipping here based on alpha means that beta values won't be correct but since alpha is infinite anyway it shouldn't matter gsc reducing from 1e 10 to 1e 6 gsc removing the isnan is na n check range check will catch the nan na n as well assert p >= 0 0 p <= 1 0+1e 10 !double ! isnan is na n p xis +ip+ +i+ +j+ = +xi xxx this assumes that ip == op ! out crf c r f lattice outputcounts output counts +ip+ +outputindex+ +output index+ += +p gsc reducing from 1e 10 to 1e 6 gsc removing the isnan is na n check range check will catch the nan na n as well assert p >= 0 0 p <= 1 0+1e 10 !double ! isnan is na n p p= +p a container for some information about a particular input position and state outputposition output position not really needed until we deal with asymmetric epsilon xxx remove this check 